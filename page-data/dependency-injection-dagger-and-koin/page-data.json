{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/dependency-injection-dagger-and-koin","result":{"data":{"post":{"__typename":"MdxPost","slug":"/dependency-injection-dagger-and-koin","title":"Dependency Injection - Dagger and Koin","date":"28-03-2020","tags":[{"name":"Dependency Injection","slug":"dependency-injection"},{"name":"Android","slug":"android"},{"name":"Koin","slug":"koin"},{"name":"Dagger","slug":"dagger"}],"description":"We take a look at how Dagger and Koin's APIs compare to one another","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dependency Injection - Dagger and Koin\",\n  \"date\": \"2020-03-28T00:00:00.000Z\",\n  \"description\": \"We take a look at how Dagger and Koin's APIs compare to one another\",\n  \"tags\": [\"Dependency Injection\", \"Android\", \"Koin\", \"Dagger\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Dependency Injection on Android has been a hot button topic for quite a while now. Opinions range from not using DI at all, to using manual DI, to swearing by Dagger, to using the host of new libraries that have been popping up.\"), mdx(\"p\", null, \"I explored Koin recently and wanted to share some thoughts regarding the experience. It also led me to have a better understanding of Dagger and DI in general. So, let\\u2019s get down to it! First, I will lay down a basic comparison of how we perform DI with both the libraries.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Disclaimer\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \":\"), \" This article assumes you are familiar with the concept of DI and Dagger. If not, feel free to go through \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://blog.usejournal.com/dependency-injection-for-beginners-56c643363e92\"\n  }), \"this\"), \" post. It also links to a video series which helped me immensely in understanding Dagger.\"), mdx(\"h1\", null, \"Modules\"), mdx(\"p\", null, \"Both the libraries treat modules a bit differently. In the case of Dagger, you\\u2019ll need modules to provide objects whose constructor cannot be annotated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Inject\"), \". But for Koin, all dependencies \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"must\"), \" be declared in a module.\"), mdx(\"p\", null, \"So looking at Koin first, here\\u2019s how you would define a module:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"module {\\n    single { PreferenceManager.getDefaultSharedPreferences(context = get()) }\\n\\n    // Others...\\n    // Recreates dependency everytime (don't actually do this with Glide, I am just using this as an example!)\\n    factory { Glide.with(application = get()) }\\n    // Scoped to the viewmodel's lifecycle.\\n    viewModel { UserProfileViewModel(userPostsUseCase = get()) }\\n}\\n\")), mdx(\"p\", null, \"On the other hand, here\\u2019s what we got for Dagger:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"@Module\\nclass AppModule {\\n\\n    @Provides\\n    @Singleton\\n    fun providePreferences(application: Application): SharedPreferences {\\n        return PreferenceManager.getDefaultSharedPreferences(application)\\n    }\\n\\n    @Provides\\n    fun provideGlideRequestManager(application: Application): RequestManager {\\n        return Glide.with(application)\\n    }\\n\\n }\\n\")), mdx(\"p\", null, \"As you can see right away, the code we have to write is much more verbose for Dagger. And I am not even including the code for providing ViewModels \\uD83D\\uDE05\"), mdx(\"h1\", null, \"Components\"), mdx(\"p\", null, \"Next, let\\u2019s take a look at components.\"), mdx(\"p\", null, \"Koin doesn\\u2019t have Components per se. You just have this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"@Module\\n    startKoin {\\n        androidContext(this@MyApplication)\\n        androidLogger(DEBUG)\\n        modules(listOf(appModule, networkModule, cacheModule))\\n    }\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"startKoin\"), \" method which takes in a list of your modules (and optionally, an Android context and logging configuration, amongst other things).\"), mdx(\"p\", null, \"In Dagger land, things again get a tad verbose. The Component plays a pretty important role as it defines our injection targets and the objects we will be providing. There is also the provision of providing external dependencies to the Dagger graph (the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"application\"), \" class in this case).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"@Singleton\\n@Component(modules = [AppModule::class, NetworkModule::class, CacheModule::class])\\ninterface AppComponent {\\n\\n    val application: Application\\n\\n    fun inject(activity: MainActivity)\\n\\n    @Component.Builder\\n    interface Builder {\\n\\n        @BindsInstance\\n        fun application(application: Application): Builder\\n\\n        fun build(): AppComponent\\n\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"To actually use it, we will need to build the component:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"val component: AppComponent by lazy {\\n    DaggerAppComponent.builder().application(this).build()\\n}\\n\")), mdx(\"h1\", null, \"Clients\"), mdx(\"p\", null, \"Now for the most interesting part! Here we will dive into what primarily differentiates Dagger and Koin and get to know a bit more about DI (and Service Locators too).\"), mdx(\"h2\", null, \"Constructor Injection\"), mdx(\"p\", null, \"Let\\u2019s take a look at constructor injection first. With Koin, you simply write your constructors as you normally would. No need for any annotations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"class UserPrefs(private val sharedPreferences: SharedPreferences)\\n\")), mdx(\"p\", null, \"However, in the case of Dagger, we see that we need to annotate the class with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Inject\"), \". Also, we need to use the verbose variant of class constructor:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"class UserPrefs @Inject constructor(private val prefs: SharedPreferences)\\n\")), mdx(\"p\", null, \"Is that it? Well, no. If the class had 3 more dependencies, in the case of Koin, we would have to find our module and convert:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-noLineNumbers\"\n  }), \"module {\\n    viewModel { ProfileViewModel(get()) }\\n}\\n\")), mdx(\"p\", null, \"to\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-noLineNumbers\"\n  }), \"module {\\n    viewModel { ProfileViewModel(get(), get(), get(), get()) }\\n}\\n\")), mdx(\"p\", null, \"And if the dependencies of any of these 4 classes had changed, well, you guessed it-add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get()\"), \" for them as well. This does seem like a whole lot of manual work, and Jake Wharton certainly seems to agree when he tweeted \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/jakewharton/status/1138111189299449856\"\n  }), \"this\"), \". And it does make sense. It can be easily seen how this can become untenable in big projects.\"), mdx(\"p\", null, \"And how does Dagger fare in this regard? Well, it\\u2019s as easy as adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Inject constructor(...)\"), \" to the class. This scales really well for bigger projects as you don't have to go around hunting for modules and modify them.\"), mdx(\"h2\", null, \"Member Injection\"), mdx(\"p\", null, \"When injecting members, Dagger and Koin provide very similar (but also very different \\uD83D\\uDE43) APIs.\"), mdx(\"p\", null, \"Going with Koin first, we see that we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"by inject()\"), \" to inject members.\"), mdx(\"p\", null, \"It is kind-of similar for Dagger, where we get a hold of the component and call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inject\"), \" manually.\"), mdx(\"p\", null, \"Looking at these examples, it seems that both Koin and Dagger seem to be acting as Service Locators. For a refresher, here is the difference between DI and SL as stated by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://martinfowler.com/articles/injection.html#UsingAServiceLocator\"\n  }), \"Martin Fowler\"), \":\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CWith service locator the application class asks for it explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class \\u2014 hence the inversion of control.\\u201D\"))), mdx(\"p\", null, \"In both our examples, the Fragment is the one requesting the dependencies. So does that mean that Dagger isn\\u2019t a DI library? Well, no. If you stop looking at it from strictly an Android perspective, you will see that we \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"can\"), \" perform member injection from outside a class with Dagger but not for Koin. Let\\u2019s take a look at another example:\"), mdx(\"p\", null, \"This is what I meant when I wrote that they have similar but different APIs. We are able to satisfy member dependencies from outside the class. In Android, we do use Dagger as a service locator, but that is only because of how the Activities and Fragments are designed. This is one of the primary confusions that I had, seeing how similar member injection is for both the libraries.\"), mdx(\"p\", null, \"You might say, \\u201COK, if I use constructor injection to a bare minimum, then I should be good with using Koin, right?\\u201D Ehhhh\\u2026. not really, no. In fact, you should be doing the opposite. Member injection should be minimized in Android. You should write as much of the code you can in constructor injected types, and only use member injection to integrate your code with the Android components.\"), mdx(\"h1\", null, \"Conclusion\"), mdx(\"p\", null, \"I wrote this post with the intention of shedding more light on the definitions of service locator, dependency injection, and how Dagger and Koin fit those definitions.\"), mdx(\"p\", null, \"Koin is definitely easier to learn and provides you with quicker build times. I have tried it in a few small to mid-sized projects and it has been a great experience using it. However, the lack of compile-time safety was missed; given that I am so used to it using Dagger for so long. Also, manual graph maintenance can start to become bothersome after a certain point. While there is no denying that learning Dagger is a monumental task and it does affect your build speeds, it does offer some sweet benefits. In the end, both Koin and Dagger are just tools. You will need to decide which one fits your needs and I hope this article will be at least of little help in deciding which one to go with!\"), mdx(\"p\", null, \"If you are interested in learning more, check out these great resources which helped me develop a better understanding of the topics discussed in this article.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=eUKtxzqLyKM\"\n  }), \"Danny Preussler\\u2019s\"), \" \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=eUKtxzqLyKM\"\n  }), \"Talk from Droidcon Berlin\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=chCsNkjotfc\"\n  }), \"Arnaud Giuliani\\u2019s\"), \" \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=chCsNkjotfc\"\n  }), \"excellent introduction to Koin\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://redd.it/d1b4i1\"\n  }), \"My Reddit thread on this topic\"))), mdx(\"hr\", null));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Dependency Injection on Android has been a hot button topic for quite a while now. Opinions range from not using DI at all, to using manual…","timeToRead":4,"banner":null}},"pageContext":{"slug":"/dependency-injection-dagger-and-koin","formatString":"DD-MM-YYYY"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}