{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/building-slide-color-picker","result":{"data":{"post":{"__typename":"MdxPost","slug":"/building-slide-color-picker","title":"Building Slide Color Picker","date":"19-07-2020","tags":[{"name":"Android","slug":"android"},{"name":"UI","slug":"ui"}],"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Building Slide Color Picker\",\n  \"date\": \"2020-07-19T00:00:00.000Z\",\n  \"description\": null,\n  \"tags\": [\"Android\", \"UI\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Recently our designer came with this gorgeous selector to pick color values on a linear scale:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://miro.medium.com/max/458/1*6ciIAtcqQ_EXEwBqlnvemw.gif\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"Even though it might look complicated, it is pretty simple once you break it down into separate components. In this article, I am going to walk you through the process of creating it from scratch.\"), mdx(\"h2\", null, \"Divide and Conquer\"), mdx(\"p\", null, \"The whole implementation can be divided into four components:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Drawing the circle\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Drawing the gradient slider\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Scaling the circle down on touch and animating the slider\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Selecting the appropriate value based on where user lifts the finger\")), mdx(\"p\", null, \"So let\\u2019s start with the first one, shall we? Actually before that, let\\u2019s lay down some ground work which will help us to write less code.\"), mdx(\"h2\", null, \"ObservableProperty\"), mdx(\"p\", null, \"We will write a nifty observable property so that we do not have to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"invalidate()\"), \" on our view every time we update a property.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"private fun <T> viewProperty(default: T) = object : ObservableProperty<T>(default) {\\n\\n    override fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean =\\n        newValue != oldValue\\n\\n    override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) {\\n        postInvalidateOnAnimation()\\n    }\\n}\\n\")), mdx(\"p\", null, \"Now instead of writing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var radius: Float = 0F\"), \" , we write \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var radius: Float by viewProperty(0f)\"), \" . Whenever the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"radius\"), \" changes, the view will be invalidated automatically. This is particularly useful during animation as you\\u2019ll see shortly.\"), mdx(\"h2\", null, \"Sizing it up\"), mdx(\"p\", null, \"Before we get to any drawing, we will need to determine how big our view will be. For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SlideColorPicker\"), \" , I decided to limit it to the size of the circle. To draw the gradient slider, we will draw outside our bounds by adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"android:clipChildren=\\u201Dfalse\\u201D\"), \" to our parent layout. Now then, let\\u2019s get to drawing!\"), mdx(\"h2\", null, \"Drawing the Circle\"), mdx(\"p\", null, \"Firstly, we will need a stroked circle which will be dragged along the vertical axis to select the color. It can be drawn easily by writing:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"canvas.drawCircle(centerX, centerCircleY, radius, circlePaint)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"centerX\"), \" is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width / 2\"), \" of the view. Since the circle will only be translated along the vertical axis, this value will never change. Similarly, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"circlePaint\"), \" will be unchanged. The two interesting properties here are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"centerCircleY\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"radius\"), \". Since changing them will require the view to be redrawn, they are defined using our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"viewProperty\"), \" delegate.\"), mdx(\"h2\", null, \"Drawing the Gradient Slider\"), mdx(\"p\", null, \"Next up is the gradient slider. It can be achieved using a rectangle; a rounded rectangle to be precise.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"canvas.drawRoundRect(\\n    left = centerX - originalRadius,\\n    top = centerY - halfRectHeight,\\n    right = centerX + originalRadius,\\n    bottom = centerY + halfRectHeight,\\n    originalRadius,\\n    originalRadius,\\n    rectanglePaint)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"halfRectHeight\"), \" will be changing on each draw call. It varies from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"originalRadius\"), \" to the expanded height, which is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"originalRadius * heightMultiplier\"), \". The following image should help in visualizing the values.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://miro.medium.com/max/2288/0*v2jJSE1jexkk6IF6.png\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"You will notice that we are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drawRoundRect\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drawCircle\"), \" to draw the colored circle in the collapsed state. It is just that the radius of the corners is equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"height/2\"), \" of the rectangle which is why it looks like a circle.\"), mdx(\"p\", null, \"As for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rectanglePaint\"), \", we apply a gradient to it when we are in the expanded state whereas in the collapsed state, we just show the selected color.\"), mdx(\"p\", null, \"We will end up with something like this\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://miro.medium.com/max/980/1*SWT4LKS6HwKQRgqSqrAxQQ.png\",\n    \"alt\": null\n  }))), mdx(\"h2\", null, \"Animation!\"), mdx(\"p\", null, \"Now comes the most interesting part \\u2014 animation!\"), mdx(\"p\", null, \"Following our divide and conquer principle, we need to do 2 things when the user touches the screen\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"scale down the circle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"expand the slider\")), mdx(\"p\", null, \"Furthermore, we want these animations to play in tandem. So, when the scale animation is at half the progress, so should be the expand animation. And when the user lifts up their finger, we want to reverse the animation.\"), mdx(\"p\", null, \"For this reason, we will be using a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.android.com/reference/kotlin/android/animation/ValueAnimator\"\n  }), \"ValueAnimator\"), \" which goes from 0 to 1 and observe the values using an update listener. First things first, let\\u2019s define an enum which will help us to identify whether the touch event is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DOWN\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UP\"), \" .\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"enum class TouchAction {\\n    DOWN, UP\\n}\\n\")), mdx(\"p\", null, \"Now, using the touch listener, we can play the animation whenever the user interacts with our view.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"when (event.action) {\\n    MotionEvent.ACTION_DOWN -> {\\n        runAnimation(TouchAction.DOWN)\\n    }\\n    MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {\\n        runAnimation(TouchAction.UP)\\n    }\\n}\\n\")), mdx(\"p\", null, \"Finally, let\\u2019s implement the function which performs the animation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"private fun runAnimation(action: TouchAction) {\\n    animator.apply {\\n        removeAllUpdateListeners()\\n        cancel()\\n        addUpdateListener {\\n            val value = it.animatedValue as Float\\n            animateCircleScale(value, action)\\n            animateRectangle(value, action)\\n            if (action == TouchAction.UP) {\\n                animateCircleToCenter(centerCircleY, value)\\n            }\\n        }\\n        start()\\n    }\\n}\\n\")), mdx(\"p\", null, \"A bit of boilerplate here, but the primary functions we are concerned with are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animateCircleScale\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animateRectangle\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"animateCircleToCenter\"), \". Let\\u2019s walk through them one by one:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"animateCircleScale-\")), \" It is responsible for (no points for guessing) animating the circle\\u2019s scale.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"private fun animateCircleScale(\\n    animatorValue: Float,\\n    action: TouchAction\\n) {\\n    val (startRadius, endRadius) = if (action == TouchAction.UP) {\\n        scaledDownCircleRadius to originalRadius\\n    } else {\\n        originalRadius to scaledDownCircleRadius\\n    }\\n    radius = lerp(startRadius, endRadius, animatorValue)\\n}\\n\")), mdx(\"p\", null, \"As you can see, we decide the start radius and end \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"radius\"), \" based on the user\\u2019s action, and then just assign the lerp-ed value to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"radius\"), \". And since radius is an observable view property, we do not need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"invalidate()\"), \" manually!\"), mdx(\"p\", null, \"If you are wondering what the lerp function does, check out \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://answers.unity.com/questions/237294/how-the-heck-does-mathflerp-work.html\"\n  }), \"this\"), \" great explanation. I will be perfectly honest, I had seen this function before in other animation tutorials, but it didn\\u2019t quite \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"click\"), \" for me until I had to use it myself \\uD83D\\uDE01\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"animateRectangle-\")), \" No points for guessing (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"didn\\u2019t he just use this phrase?\"), \") what this function does \\u2014 it updates the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"halfRectHeight\"), \" property which in turn triggers the re-drawing of the view. Doing this each time the value animator updates results in the effect of expanding slider as seen in the animation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"private fun animateRectangle(\\n    animatorValue: Float,\\n    action: TouchAction\\n) {\\n    val (startHeight, endHeight) = if (action == TouchAction.UP) {\\n        expandedHeight to originalRadius\\n    } else {\\n        originalRadius to expandedHeight\\n    }\\n    rectHeight = lerp(startHeight, endHeight, animatorValue)\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"animateCircleToCenter-\")), \" You won\\u2019t get any points for guessing what this function does (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"this is the third time, what are these writing skills\"), \") \\u2014 it animates the circle back to the center when the user lifts their finger. This is achieved by\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"centerCircleY = lerp(currentY, centerY, animatorValue)\\n\")), mdx(\"p\", null, \"We will also need to add the gradient to the rectangle paint on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ACTION_DOWN\"), \" . This is done using a linear gradient\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"val gradient = LinearGradient(\\n    x0 = 0F,\\n    y0 = originalRadius - expandedHeight,\\n    x1 = 0F,\\n    y1 = originalRadius + expandedHeight,\\n    startColor,\\n    endColor,\\n    Shader.TileMode.MIRROR\\n)\\n\")), mdx(\"p\", null, \"It\\u2019s height will be equal to the height of our view in expanded state. Then we just apply it to the paint like so\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"colorGradientPaint.shader = gradient\\n\")), mdx(\"p\", null, \"We now have something like this\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://miro.medium.com/max/1200/1*HQk4jXeObYH2U8w_Dcrglg.gif\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"We are slowly but surely getting there! \\uD83D\\uDE4C\"), mdx(\"p\", null, \"Now let\\u2019s add drag support for the circle. Simply add an additional branch to the when expression in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onTouch\"), \" method for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ACTION_MOVE\"), \" and set \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"centerCircleY\"), \" to the Y value of the motion event.\"), mdx(\"h2\", null, \"Value Selection\"), mdx(\"p\", null, \"Lastly, let\\u2019s update the selected color.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-kotlin\"\n  }), \"private fun setSelectedColor(position: Float) {\\n    val progress = (position - upperBound) / (lowerBound - upperBound\\n    val colorRes = ArgbEvaluatorCompat.getInstance().evaluate(progress, startColor, endColor)\\n    colorGradientPaint.shader = null\\n    colorGradientPaint.color = colorRes\\n}\\n\")), mdx(\"p\", null, \"We calculate at what point the user lifts their finger along the gradient rectangle. Then we evaluate what color will that progress value evaluate to using the ARGB Evaluator. Once we calculate that color, we set apply that to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rectanglePaint\"), \" and remove the gradient.\"), mdx(\"p\", null, \"Just a little disclaimer, this view doesn\\u2019t let you pick the exact values and nor does it aim to (you\\u2019ll find that the maths reflects that \\uD83D\\uDE05). The current implementation is what we wanted. You can easily modify parts of this code such that the color selection becomes more precise.\"), mdx(\"h2\", null, \"Fin\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://miro.medium.com/max/964/1*hupqeJQcvCHuQVG3Oz8Fog.gif\",\n    \"alt\": null\n  }))), mdx(\"p\", null, \"So that\\u2019s it! This is the first time I have tried to implement a custom view with this many moving parts. It was a really interesting experience so I thought I might share it. I was thinking about creating a library but decided against that due to the limited usecase. Nevertheless, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/shkcodes/SlideColorPicker\"\n  }), \"here\"), \" is a repo containing the full code.\"), mdx(\"p\", null, \"Thanks for sticking around till the end, hope you learned something!\\uD83D\\uDC4B\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Recently our designer came with this gorgeous selector to pick color values on a linear scale: Even though it might look complicated, it isâ€¦","timeToRead":4,"banner":null}},"pageContext":{"slug":"/building-slide-color-picker","formatString":"DD-MM-YYYY"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}