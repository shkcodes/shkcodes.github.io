{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/dependency-injection-for-beginners","result":{"data":{"post":{"__typename":"MdxPost","slug":"/dependency-injection-for-beginners","title":"Dependency Injection for Beginners","date":"28-03-2020","tags":[{"name":"Dependency Injection","slug":"dependency-injection"},{"name":"Android","slug":"android"},{"name":"Dagger","slug":"dagger"}],"description":"Explaining what Dependency Injection means at a basic level","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dependency Injection for Beginners\",\n  \"date\": \"2020-03-28T00:00:00.000Z\",\n  \"description\": \"Explaining what Dependency Injection means at a basic level\",\n  \"tags\": [\"Dependency Injection\", \"Android\", \"Dagger\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component '\" + name + \"' was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"You might have heard of dependency injection. It\\u2019s been one of the hot topics in the Android community for the past few years . So you look around on the internet, find articles about Dagger and are lost when people start mentioning Modules, Components, and Scopes. That is because those articles don\\u2019t do a very good job of explaining what is dependency injection (Thermosiphon anyone?) & why you need it.\"), mdx(\"p\", null, \"Before diving into such articles, you must have a clear understanding of why are you using dependency injection (DI) and what benefits does it provide you. As the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.fragiledeveloper.com/2017/05/the-principle-of-applying-principles.html\"\n  }), \"Principle of Applying Principles\"), \" states, \\u201CThe good and proper application of each principle, pattern and practice requires you to understand why you are doing what you\\u2019re doing\\u201D. So this article will try to answer the following questions :\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What is a dependency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What is dependency injection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why should you use it\")), mdx(\"hr\", null), mdx(\"h2\", null, \"What is a dependency\"), mdx(\"p\", null, \"As you can infer from its English meaning, the word dependency indicates that a part of code depends on some other part of code. It could be either \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"loose coupling\"), \" (where the code depends on an abstract class or interface) or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"strong coupling\"), \" (where the code depends on a concrete class). I believe examples provide a better understanding so lets see an example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java:title=snippet_1\"\n  }), \"Class A {\\n\\n   public int doSomeWork() {\\n       B objectB = new B();\\n       int result = objectB.getResult();\\n       int finalResult = result * 2;\\n       return finalResult;\\n   }\\n\\n}\\n\")), mdx(\"p\", null, \"The function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" uses some functionality from class B. So class A has a dependency on class B. If class B required some constructor parameters, it would become the responsibility of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" to provide those parameters.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java:title=snippet_2\"\n  }), \"class A {\\n\\n   public int doSomeWork(int p1, int p2, String p3) {\\n       B objectB = new B(p1, p2, p3);\\n       int result = objectB.getResult();\\n       int finalResult = result * 2;\\n       return finalResult;\\n   }\\n\\n}\\n\")), mdx(\"p\", null, \"If the function depended on more objects each of which required multiple constructor parameters, the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" would become too unwieldy. Instead of just doing the specific thing it was meant to do, it would also contain code for creation of the needed objects. As you can see, it is not really wise to write our code this way. Now onto our second question, what is dependency injection.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"What is dependency injection\"), mdx(\"p\", null, \"The English language to our rescue again! Dependency injection is the act of injecting dependencies. Well, injection is just a fancy word for providing. So dependency injection is the act of providing dependencies.\"), mdx(\"p\", null, \"Hence, instead of this,\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java:title=snippet_3\"\n  }), \"class A {\\n\\n   public int doSomeWork(int p1, int p2, String p3) {\\n       B objectB = new B(p1, p2, p3);\\n       int result = objectB.getResult();\\n       int finalResult = result * 2;\\n       return finalResult;\\n   }\\n\\n}\\n\\n\")), mdx(\"p\", null, \"we could have this\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-java:title=snippet_4\"\n  }), \"class A {\\n\\n    private B objectB;\\n\\n    public A(B objectB) {\\n        this.objectB = objectB;\\n    }\\n\\n    public int doSomeWork() {\\n        int result = objectB.getResult();\\n        int finalResult = result * 2;\\n        return finalResult;\\n    }\\n\\n}\\n\")), mdx(\"p\", null, \"That\\u2019s it! You just performed dependency injection. The dependency (Class B) was injected (as a constructor parameter) into the code which needed it (Class A). All the fancy DI frameworks and libraries try to help you in making your code less like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"snippet_3\"), \" and more like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"snippet_4\"), \". Well, why would you want to do that? Let\\u2019s move on to our next section to find out.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"Why should you use it\"), mdx(\"p\", null, \"1) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Reducing responsibility\"), \" : In code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"snippet_4\"), \", the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" is not responsible for the creation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"objectB\"), \". It does not care how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"objectB\"), \" is provided or who provides it. It\\u2019s only responsibility is to \\u2018do some work\\u2019, and the fewer responsibilities a piece of code has, the less error prone it is.\"), mdx(\"p\", null, \"2) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Easier testing\"), \" : In code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"snippet_3\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" is explicitly responsible for creating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"objectB\"), \". For testing, the creation of object should be done outside the code to be tested. As an example, we could pass a fake \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"objectB\"), \" in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"snippet_4\"), \" to test \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \".\"), mdx(\"p\", null, \"3) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"We don\\u2019t need to change unrelated code\"), \" : In future, if we change B (say, we add a constructor parameter), it will require us to change \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomeWork\"), \" too. If we had initialized B in 10 places throughout our code, it would have required us to change the code in 10 different places If we use dependency injection, we will just modify the part where we initialized B.\"), mdx(\"p\", null, \"4) \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Improved code reusability :\"), \" If you use dependency injection, you just need to initialize B just once. You can then just pass that object to whatever part of code that requires it. This makes our code more reusable.\"), mdx(\"hr\", null), mdx(\"h2\", null, \"What next\"), mdx(\"p\", null, \"For a more concrete tutorial about dependency injection on Android, check out \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=Qwk7ESmaCq0&list=PLuR1PJnGR-Ih-HXnGSpnqjdhdvqcwhfFU\"\n  }), \"this\"), \" playlist by TwistedEquations. You can see how creating each dependency manually can get quickly get out of hand.\"), mdx(\"p\", null, \"I would recommend you to stay away from Dagger Android till you get comfortable with @Module, @Provides, @Inject and @Component. Although it introduces a lot of stuff to reduce the boilerplate required for Dagger, you need to have a clear understanding of the aforementioned concepts before you try it. Learning Dagger and Dagger Android together would be too much for a beginner.\"), mdx(\"hr\", null), mdx(\"p\", null, \"So that\\u2019s it. I have tried keeping this article simple and not use any of the technical terms usually used while explaining dependency injection. Thanks for reading my first article!\"), mdx(\"hr\", null), mdx(\"hr\", null), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This article was originally published on \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://blog.usejournal.com/dependency-injection-for-beginners-56c643363e92\"\n  }), \"Medium\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"You might have heard of dependency injection. It’s been one of the hot topics in the Android community for the past few years . So you look…","timeToRead":3,"banner":null}},"pageContext":{"slug":"/dependency-injection-for-beginners","formatString":"DD-MM-YYYY"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}